#!/usr/bin/env bash
# am - Agent Manager
# A CLI tool for managing multiple AI coding agent sessions

set -euo pipefail

# Version
AM_VERSION="0.1.0"

# Determine script directory (resolve symlinks)
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    AM_SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$AM_SCRIPT_DIR/$SOURCE"
done
AM_SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
AM_LIB_DIR="$AM_SCRIPT_DIR/lib"

# Usage information (no dependencies needed)
usage() {
    cat <<'EOF'
am - Agent Manager v0.1.0

Manage multiple AI coding agent sessions with an interactive fzf interface.

USAGE:
    am [command] [options]

COMMANDS:
    (default)           Open interactive session browser
    list, ls            List all sessions
    list --json, -j     Output sessions as JSON
    new, create, n      Create a new agent session
    attach, a           Attach to a session by name (exact, prefix, or fuzzy)
    kill, rm, k         Kill a session
    kill --all, -a      Kill all agent-manager sessions
    config              Show or change saved defaults
    info, i             Show detailed session info
    status, s           Show summary of all sessions
    help                Show this help message

SHORTCUT:
    am <path>           Same as 'am new <path>'

OPTIONS FOR 'new':
    -t, --type      Agent type: claude, codex, gemini (saved default applies)
    -n, --name      Custom task description
    -d, --dir       Directory (can also be positional arg)
    -w, --worktree  Enable git worktree isolation (Claude only)
                    Optional: -w <name> to set worktree name (default: am-XXXXXX)
    --yolo          Enable permissive mode (mapped per agent, uses sb sandbox)
    --no-yolo       Disable permissive mode even if enabled by default
    --              Pass remaining args to agent (e.g., -- --resume)

KEYBINDINGS (interactive browser):
    Enter           Attach to selected session
    Ctrl-N          Create new session (interactive: directory > agent > mode)
    Ctrl-X          Kill selected session
    Ctrl-R          Refresh session list
    Ctrl-P          Toggle preview panel
    Ctrl-J/K        Scroll preview up/down
    Ctrl-D/U        Scroll preview half-page down/up
    ?               Show inline help

KEYBINDINGS (inside tmux session):
    Prefix + a      Switch to last am session
    Prefix + n      Open a popup to create a new session
    Prefix + s      Open am browser popup
    Prefix + x      Kill the current am session
    Prefix + d      Detach from session
    Prefix Up/Down  Switch panes (agent/shell)
    :am             Open am browser (tmux command)

EXAMPLES:
    am                              # Open interactive browser
    am new                          # New session in current dir (uses defaults)
    am new ~/code/myproject         # New session in specific directory
    am new -t codex ~/code/proj     # New codex session
    am new -n "fix auth" .          # Session with task description
    am attach am-abc123             # Attach to session by name
    am kill am-abc123               # Kill specific session

DEPENDENCIES:
    tmux >= 3.0, fzf >= 0.40, jq, git

CONFIGURATION:
    Sessions stored in: ~/.agent-manager/
    See README for tmux keybinding setup.
EOF
}

# Handle help/version before loading libs (no deps needed)
case "${1:-}" in
    help|--help|-h)
        usage
        exit 0
        ;;
    version|--version|-v)
        echo "am version $AM_VERSION"
        exit 0
        ;;
esac

# Now source all library files (they check dependencies)
source "$AM_LIB_DIR/utils.sh"
source "$AM_LIB_DIR/config.sh"
source "$AM_LIB_DIR/tmux.sh"
source "$AM_LIB_DIR/registry.sh"
source "$AM_LIB_DIR/agents.sh"
source "$AM_LIB_DIR/fzf.sh"

# Command: list
cmd_list() {
    local json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json|-j)
                json=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    if $json; then
        fzf_list_json
    else
        # Interactive mode
        local result
        result=$(fzf_main)

        if [[ "$result" == __NEW_SESSION__* ]]; then
            # Parse: __NEW_SESSION__|directory|agent_type|flags
            local directory agent_type flags
            directory=$(echo "$result" | cut -d'|' -f2)
            agent_type=$(echo "$result" | cut -d'|' -f3)
            flags=$(echo "$result" | cut -d'|' -f4-)

            # Create new session with selected directory, type, and flags
            # shellcheck disable=SC2086
            cmd_new_internal "$directory" "$agent_type" $flags
        elif [[ -n "$result" ]]; then
            # Attach to selected session
            tmux_attach "$result"
        fi
    fi
}

# Internal: create session with directory, type, and flags (called from fzf_main)
# Usage: cmd_new_internal <directory> [agent_type] [flags...]
cmd_new_internal() {
    local directory="$1"
    local agent_type="${2:-$(am_default_agent)}"
    shift 2 2>/dev/null || shift $#
    local agent_args=("$@")

    local session_name
    session_name=$(agent_launch "$directory" "$agent_type" "" "" "${agent_args[@]}")

    if [[ -n "$session_name" ]]; then
        tmux_attach "$session_name"
    fi
}

# Command: new
cmd_new() {
    local directory="."
    local dir_given=false
    local agent_type=""
    local task=""
    local worktree_name=""
    local agent_args=()
    local yolo_override=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--type)
                agent_type="$2"
                shift 2
                ;;
            -n|--name|--task)
                task="$2"
                shift 2
                ;;
            -d|--dir)
                directory="$2"
                dir_given=true
                shift 2
                ;;
            -w|--worktree)
                shift
                # Next arg is optional name â€” if it starts with - or is a directory, use default
                if [[ $# -gt 0 && "$1" != -* && ! -d "$1" ]]; then
                    worktree_name="$1"
                    shift
                else
                    worktree_name="__auto__"  # sentinel: generate from session hash
                fi
                ;;
            --yolo|--dangerously-skip-permissions)
                agent_args+=("--yolo")
                yolo_override="true"
                shift
                ;;
            --no-yolo)
                yolo_override="false"
                shift
                ;;
            --)
                shift
                agent_args=("$@")
                break
                ;;
            -h|--help)
                echo "Usage: am new [options] [directory] [-- agent_args...]"
                echo ""
                echo "If no directory specified, opens interactive picker."
                echo ""
                echo "Options:"
                echo "  -t, --type    Agent type (claude, codex, gemini)"
                echo "  -n, --name    Task description"
                echo "  -d, --dir     Working directory"
                echo "  -w, --worktree  Enable git worktree isolation (Claude only)"
                echo "                  Optional: -w <name> for custom worktree name"
                echo "  --yolo        Enable permissive mode (mapped per agent, uses sb sandbox)"
                echo "  --no-yolo     Disable permissive mode even if enabled by default"
                echo "  --            Pass remaining args to agent command"
                echo ""
                echo "Examples:"
                echo "  am new                          # Interactive directory picker"
                echo "  am new ~/project                # Specific directory"
                echo "  am new --yolo ~/project         # Permissive mode"
                echo "  am new ~/project -- --resume    # With agent args"
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                return 1
                ;;
            *)
                directory="$1"
                dir_given=true
                shift
                ;;
        esac
    done

    # If no directory specified and running interactively, offer picker
    if [[ "$dir_given" == false && -t 0 ]]; then
        local picked
        picked=$(fzf_pick_directory)
        if [[ -n "$picked" ]]; then
            directory="$picked"
        else
            log_info "Cancelled"
            return 0
        fi
    fi

    # If no agent type specified and running interactively, offer picker
    if [[ -z "$agent_type" && -t 0 ]]; then
        if ! agent_type=$(fzf_pick_agent "$(am_default_agent)"); then
            log_info "Cancelled"
            return 0
        fi
    fi
    agent_type="${agent_type:-$(am_default_agent)}"

    # If running interactively and no agent args provided via CLI, show mode picker
    if [[ ${#agent_args[@]} -eq 0 && -t 0 ]]; then
        local mode_flags yolo_default
        yolo_default=$(am_default_yolo_enabled && echo true || echo false)
        if mode_flags=$(fzf_pick_mode "$yolo_default"); then
            # shellcheck disable=SC2086
            agent_args=($mode_flags)
        else
            log_info "Cancelled"
            return 0
        fi
    elif [[ "$yolo_override" != "false" ]] && am_maybe_apply_default_yolo "${agent_args[@]}"; then
        agent_args+=("--yolo")
    fi

    # Launch agent
    local session_name
    session_name=$(agent_launch "$directory" "$agent_type" "$task" "$worktree_name" "${agent_args[@]}")

    # Auto-attach to new session
    if [[ -n "$session_name" ]]; then
        tmux_attach "$session_name"
    fi
}

# Resolve a session name: try exact match, then with prefix
# Usage: resolve_session <name>
# Returns: resolved session name on stdout, or returns 1 if not found
resolve_session() {
    local name="$1"
    if tmux_session_exists "$name"; then
        echo "$name"
    elif tmux_session_exists "${AM_SESSION_PREFIX}${name}"; then
        echo "${AM_SESSION_PREFIX}${name}"
    else
        return 1
    fi
}

# Command: attach
cmd_attach() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Session name required"
        echo "Usage: am attach <session-name>"
        return 1
    fi

    # Try exact or prefixed match
    local resolved
    if resolved=$(resolve_session "$name"); then
        tmux_attach "$resolved"
        return 0
    fi

    # Fuzzy match
    local matches
    matches=$(tmux_list_am_sessions | grep -i "$name" || true)
    local count
    count=$(echo "$matches" | grep -c . || echo 0)

    if [[ $count -eq 0 ]]; then
        log_error "No session found matching: $name"
        return 1
    elif [[ $count -eq 1 ]]; then
        tmux_attach "$matches"
    else
        log_info "Multiple matches found:"
        echo "$matches"
        echo ""
        echo -n "Enter session name: "
        read -r selected
        if [[ -n "$selected" ]]; then
            tmux_attach "$selected"
        fi
    fi
}

# Command: kill
cmd_kill() {
    if [[ $# -eq 0 ]]; then
        log_error "Session name required (or --all)"
        echo "Usage: am kill <session-name> | --all"
        return 1
    fi

    case "$1" in
        --all|-a)
            local session_count
            session_count=$(tmux_count_am_sessions)
            if [[ $session_count -eq 0 ]]; then
                log_info "No sessions to kill"
                return 0
            fi
            echo -n "Kill ALL agent-manager sessions? [y/N] "
            read -r answer
            if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
                local count
                count=$(agent_kill_all)
                log_success "Killed $count sessions"
            else
                log_info "Aborted"
            fi
            ;;
        *)
            local resolved
            if resolved=$(resolve_session "$1"); then
                agent_kill "$resolved"
            else
                log_error "Session not found: $1"
                return 1
            fi
            ;;
    esac
}

# Command: config
cmd_config() {
    local subcmd="${1:-list}"
    [[ $# -gt 0 ]] && shift

    case "$subcmd" in
        list|show)
            [[ $# -eq 0 ]] || {
                log_error "Usage: am config [list|show]"
                return 1
            }
            am_config_print
            ;;
        get)
            local raw_key="${1:-}"
            if [[ -z "$raw_key" ]]; then
                log_error "Usage: am config get <agent|yolo|logs>"
                return 1
            fi
            local key
            if ! key=$(am_config_key_alias "$raw_key"); then
                log_error "Unknown config key: $raw_key"
                return 1
            fi
            case "$key" in
                default_agent)
                    am_default_agent
                    ;;
                default_yolo)
                    am_default_yolo_enabled && echo true || echo false
                    ;;
                stream_logs)
                    am_stream_logs_enabled && echo true || echo false
                    ;;
            esac
            ;;
        set)
            local raw_key="${1:-}"
            local value="${2:-}"
            if [[ -z "$raw_key" || -z "$value" ]]; then
                log_error "Usage: am config set <agent|yolo|logs> <value>"
                return 1
            fi
            local key key_type
            if ! key=$(am_config_key_alias "$raw_key"); then
                log_error "Unknown config key: $raw_key"
                return 1
            fi
            key_type=$(am_config_key_type "$key")
            if ! am_config_value_is_valid "$key" "${value,,}"; then
                log_error "Invalid value for $raw_key: $value"
                return 1
            fi
            am_config_set "$key" "${value,,}" "$key_type"
            am_config_print
            ;;
        unset|rm)
            local raw_key="${1:-}"
            if [[ -z "$raw_key" ]]; then
                log_error "Usage: am config unset <agent|yolo|logs>"
                return 1
            fi
            local key
            if ! key=$(am_config_key_alias "$raw_key"); then
                log_error "Unknown config key: $raw_key"
                return 1
            fi
            am_config_unset "$key"
            am_config_print
            ;;
        help|-h|--help)
            cat <<'EOF'
Usage:
  am config                 Show effective defaults
  am config get <key>       Get one value
  am config set <key> <v>   Save a default
  am config unset <key>     Remove a saved value

Keys:
  agent   Default agent type
  yolo    Default permissive mode (true/false)
  logs    Default pane log streaming (true/false)

Precedence:
  CLI flag > environment variable > saved config > built-in default
EOF
            ;;
        *)
            log_error "Unknown config subcommand: $subcmd"
            return 1
            ;;
    esac
}

# Command: info
cmd_info() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Session name required"
        echo "Usage: am info <session-name>"
        return 1
    fi

    local resolved
    if ! resolved=$(resolve_session "$name"); then
        log_error "Session not found: $name"
        return 1
    fi

    echo "${BOLD}Session: $resolved${RESET}"
    echo ""
    agent_info "$resolved"
}

# Command: status
cmd_status() {
    registry_gc >/dev/null 2>&1

    local count
    count=$(tmux_count_am_sessions)

    echo "${BOLD}Agent Manager Status${RESET}"
    echo "===================="
    echo ""
    echo "Active sessions: $count"
    echo ""

    if [[ $count -gt 0 ]]; then
        echo "${BOLD}Sessions:${RESET}"
        fzf_list_simple
    else
        echo "Run 'am new' to create your first session."
    fi
}

# Main entry point
main() {
    # Initialize
    am_init
    am_config_init

    # Check dependencies
    require_cmd tmux
    require_cmd fzf
    require_cmd jq

    # Parse command
    local cmd="${1:-list}"
    [[ $# -gt 0 ]] && shift

    case "$cmd" in
        list-internal)
            fzf_list_sessions
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        new|create|n)
            cmd_new "$@"
            ;;
        attach|a)
            cmd_attach "$@"
            ;;
        kill|rm|k)
            cmd_kill "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        info|i)
            cmd_info "$@"
            ;;
        status|s)
            cmd_status
            ;;
        *)
            # If it looks like a path, treat as "new <path>"
            if [[ -d "$cmd" ]]; then
                cmd_new "$cmd" "$@"
            else
                log_error "Unknown command: $cmd"
                echo "Run 'am help' for usage"
                exit 1
            fi
            ;;
    esac
}

main "$@"
